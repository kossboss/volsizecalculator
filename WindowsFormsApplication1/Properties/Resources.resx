<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="ico1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\icon.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="CantAddMore" xml:space="preserve">
    <value>Cant add more than 60 different sizes of drives.</value>
  </data>
  <data name="AddDriveSize" xml:space="preserve">
    <value>ADD DRIVE SIZE</value>
  </data>
  <data name="DefautMessage" xml:space="preserve">
    <value>Are you sure you want to default the drive size entries to default?</value>
  </data>
  <data name="InvalidDriveSize" xml:space="preserve">
    <value>That is an invalid drive size. Just write the number in GB without the unit. So if it was 750 GB drive. I would just write 750.</value>
  </data>
  <data name="WhatToDelete" xml:space="preserve">
    <value>What drive would you like to delete? [Just write the GB size of the drive, so if had a 4000 GB drive I would just type 4000]</value>
  </data>
  <data name="NeedAtLeast1Drive" xml:space="preserve">
    <value>Got to have at least 1 drive size on the screen.</value>
  </data>
  <data name="DeleteDriveSize" xml:space="preserve">
    <value>DELETE DRIVE SIZE</value>
  </data>
  <data name="WhatToAdd" xml:space="preserve">
    <value>What size of drive would you like to add? [Gigabytes in base 10, drive manufacturer units]</value>
  </data>
  <data name="HelpMessage" xml:space="preserve">
    <value>=== Welcome to XRaid Calculator, By: kossboss ===

This is strictly just educational only. However I have made the numbers come out pretty close to the actual values (+- 1% error).

--How to use?--
First select how many drives you can put in basically its the number of slots in the system. You do not have to fill up all the slots. You can have a max of 60 slots/drives. Then select the architecture of the chip (whether its Sparc, Intel or ARM based). Then select the snapshot you wish to assign for snapshot backups. Finally pick the drives in the system. Also you can clear your selection by right clicking in a one of the drive checkbox lists and selecting Clear Selection. You can also right click in the checkbox list and click on "Select All" and have it help you select a certain drive size across all the disks.

--How to read results--
The results that matter are highlighted with yellow and bold red text.
The blue and red color coding is for comparing different drive layout scenarios.

--Comparing---
Select a scenerio for example Intel unit, 100GB Snapshot, four 2TB drives and your wondering how much bigger the volume would be If you upgraded to all 3 TB drives. Just select that scenario and then hit the SET BASELINE button and then select all 3TB drives. Now look at the numbers. The Bold red is the current values with the 3TB drives, The Bold blue is the old values with the 2TB drives. The light blue is the differences and the percent change.

--Need another drive size?--
By default your given the sizes 500,750,1000,1500,2000, and 3000 GB. Those values are the commericial Gigabytes used by drive manufacturer (they are base 10). Hence in a real world scenerio you get much less by a factor of about 93%. You can put in different drive sizes and take away different drive sizes, just right click in any of the drive boxs and follow the options. If I wanted to add a 4 TB drive to all slots, I would right click in any of the drive boxes and hit ADD DRIVE then I would type in 4000 and hit enter.

--Whats different between this and "real life" real-world READYNAS?--
**WARNING** (1) Time independence:
This program is time independent meaning it does not care about the chronological order that you add or remove drives. In real-life each system preforms under its very own characteristics when drives are added and does depend on time(in a way), for example one rule that doesnt get exercised in this program but applies in real world Readynas: If your first drive was a 2 TB drive, and then you add a smaller drive, The expansion wouldnt work.

**WARNING** (2) Drive size limitations:
With Sparc units, Intel units prior to and including 4.2.15 you cannot have drives bigger than 2 TBs. They will simply not work or will just be recognized as 2 TB drives. So a four 3TB drives is equivalent to having four 2TB drives on firmware 4.2.15. To take advantage of the full size: Please backup your data, update to the newest firmware (so 4.2.16 and higher) and prefarbly factory default with the big drives in place and when done copy your backed up data back over.

**WARNING** (3) Limitations of recent Intel units:
Volume expansion will not work beyond 16 TB. To support 16 TB or greater, you’ll have to factory default with that capacity in place.

**WARNING** (4) What values to read?
When you have 1 disk - it give you just one value which is RAID 0.
When you have 2 disk - read the RAID 5 value (it also represents the RAID 1 value)
When you have 3 disk - read the RAID 5 value, however RAID 6 does give a correct but theoretical value.
When you have 4+ disks - both values work.</value>
  </data>
  <data name="HelpMessage1" xml:space="preserve">
    <value>NOTE: Look at the BOLD RED NUMBERS FOR THE CURRENT VALUE The numbers here are based on a calculation and may vary in the actual system. Also note this program is time independent meaning it does not care about the chronological order that you add or remove drives. In real-life each system preforms under its very own characteristics when drives are added and does depend on time(in a way), for example: if your first drive was a 2TB drive, I would not be able to add smaller drives there after to expand. So hence, each calculation is as if you have factory defaulted and built an XRAID system out of the drives that you have selected. Other factors determine what final size your system will be. Also you can change the number of drives, please put in integer values, (however decimal point values can be used). You cant add more than 60 different kinds, and also you cannot go below 1 kind of drive. I just added the ability to compare different setups. You can start a comparison with the SET BASELINEbutton, clicking that will put the current values into the blue position and then from then own every new value will be in red. The none bold blue is the difference from current to new. Regards, Kostia Khlebopros of NETGEAR.</value>
  </data>
  <data name="WhatToSelect" xml:space="preserve">
    <value>What drive would you like to select across all of the drive bays? [Just write the GB size of the drive, so if had a 4000 GB drive I would just type 4000]</value>
  </data>
  <data name="WhatToSelectTitle" xml:space="preserve">
    <value>DRIVE SELECTION</value>
  </data>
</root>